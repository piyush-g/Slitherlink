(defparameter rows 5)
(defparameter colomns 5)
(defparameter board nil)
(defparameter symbol-horizontal 'H)
(defparameter symbol-vertical 'V)
(defparameter symbol-right 'R)
(defparameter symbol-left 'L)
(defparameter symbol-top 'T)
(defparameter symbol-bottom 'B)
(defparameter horizontal-edges nil)
(defparameter vertical-edges nil)
(defparameter horizontal-edges-priority-values NIL)
(defparameter vertical-edges-priority-values NIL)
(defparameter filename nil)
(defparameter input 0)
(defparameter x 0)
(defparameter y 0)
(defparameter z 0)
(defparameter edge-count 0)
(defparameter temp 0)
(defparameter temph nil)
(defparameter tempv nil)
(defparameter existing-neighbors ())
(defparameter pre-existing-neighbors ())
(defparameter edge-count-in-loop 0)
(defparameter first-edge nil)
(defparameter pre-existing-edges (make-hash-table :test 'equal))
(defparameter priority 0)
(defparameter final-list NIL)
(defparameter moves 0)
(defparameter limit-moves 1000000)
(defparameter out NIL)
(defparameter output-filename NIL)

(defun construct-list(items value)
	(cond ((>= 1 items) (list value)) 
				( t (append (list value) (construct-list (1- items) value)))))

(defun construct-matrix(row colomn value)
	(cond ((>= 1 row) (list (construct-list colomn value)))
				(t (cons (construct-list colomn value) (construct-matrix (1- row) colomn value)))))

( defun element(board i j)
	(nth j (nth i board)))

(defun set-element(board i j value)
	(setf (nth j (nth i board)) value))

(defun get-neighbor-horizontal-edge(i j)
	 (list 	(list i (1- j) symbol-horizontal) (list i (1+ j) symbol-horizontal) 
	 				(list (1- i) j symbol-vertical) (list (1- i) (1+ j) symbol-vertical)
	 				(list i j symbol-vertical) (list i (1+ j) symbol-vertical)))

(defun get-neighbor-vertical-edge(i j)
	(list (list (1- i) j symbol-vertical) (list (1+ i) j symbol-vertical)
				(list i (1- j) symbol-horizontal) (list i j symbol-horizontal)
				(list (1+ i) (1- j) symbol-horizontal) (list (1+ i) j symbol-horizontal)))

(defun get-neighbors(edge)
	(if (equal (nth 2 edge) symbol-horizontal) (get-neighbor-horizontal-edge (nth 0 edge)(nth 1 edge))
																						(get-neighbor-vertical-edge (nth 0 edge)(nth 1 edge))	)
)

(defun is-edge-exists(edge)
	( if (>= (nth 0 edge) 0)
		( if (>= (nth 1 edge) 0)
			( if (equal 1 
							( if 	(equal symbol-horizontal (nth 2 edge))
										(element horizontal-edges (nth 0 edge)(nth 1 edge)) 
										(element vertical-edges (nth 0 edge)(nth 1 edge))
							)
						)
				;;----------------------
				T
				NIL
			)
		)
	)
)

(defun is-edge-does-not-exists(edge)
	( if (>= (nth 0 edge) 0)
		( if (>= (nth 1 edge) 0)
			( if (equal 0 
							( if 	(equal symbol-horizontal (nth 2 edge))
										(element horizontal-edges (nth 0 edge)(nth 1 edge)) 
										(element vertical-edges (nth 0 edge)(nth 1 edge))
							)
						)
				;;----------------------
				T
				NIL
			)
		)
	)
)

(defun convert-edge(edge)
	(if (equal edge NIL) NIL)
	(if (equal (nth 2 edge) symbol-horizontal)
		(convert-horizontal-edge (nth 0 edge) (nth 1 edge))
		(convert-vertical-edge (nth 0 edge) (nth 1 edge))
	)
)

(defun convert-horizontal-edge(i j)
	(if (not (equal 0 i))
		(list i (1+ j) symbol-bottom)
		(list (1+ i) (1+ j) symbol-top)
	)
)

(defun convert-vertical-edge(i j)
	(if (not (equal 0 j))
		(list (1+ i) j symbol-right)
		(list (1+ i) (1+ j) symbol-left)
	)
)

(defun get-not-existing-edges(edge-list)
	(setf existing-neighbors nil)
	(loop 
		for edge in edge-list do
		(if (equal T (is-edge-does-not-exists edge))
			(if (equal nil existing-neighbors)
				(setf existing-neighbors (list edge))
				(setf existing-neighbors (append existing-neighbors (list edge)))
			)
		)
	)
	existing-neighbors
)

(defun get-existing-edges(edge-list) 
	(setf existing-neighbors nil)
	(loop 
		for edge in edge-list do
		(if (equal T (is-edge-exists edge))
			(if (equal nil existing-neighbors)
				(setf existing-neighbors (list edge))
				(setf existing-neighbors (append existing-neighbors (list edge)))
			)
		)
	)
	existing-neighbors
)

(defun get-non-existing-neighbor-edges(prev-edge edge)
	(let ((n1 (get-neighbor-on-first-side edge))
				(n2 (get-neighbor-on-second-side edge)))
		(if (is-edge-in-list prev-edge n1)
			(get-not-existing-edges n2)
			(get-not-existing-edges n1)
		)
	)
		;(get-not-existing-edges (get-neighbors edge))
)

(defun get-existing-neighbor-edges(edge)
		(get-existing-edges (get-neighbors edge))
) 

(defun get-next-edge-in-loop(neighbor-list prev-edge)
	(if (are-edges-equal prev-edge (car neighbor-list)) 
			(car (cdr neighbor-list)) 
			(if (are-edges-equal prev-edge (car(cdr neighbor-list))) (car neighbor-list))
	)
)

( defun read-file(filename)
	(let ((in (open filename :if-does-not-exist nil)))
		(setq	rows (read in))
		(setq	colomns (read in))
		(setq board (construct-matrix rows colomns 5))
		(setq horizontal-edges (construct-matrix (1+ rows) colomns 0))
		(setq vertical-edges (construct-matrix rows (1+ colomns) 0))
		(setq horizontal-edges-priority-values (construct-matrix (1+ rows) colomns 0))
		(setq vertical-edges-priority-values (construct-matrix rows (1+ colomns) 0))

	  (when in
	    (loop for i = (read in nil)
	    			for j = (read in nil)
	    			for val = (read in nil)
	    			while val  do (set-element board i j val))
	    (close in)
	  )
  )
)

;; helper function for finding first element in the matrix with value 1.
;; used to find the first edge 
(defun get-first-element-in-list(lst row colomn edge-type)
	(loop for i from 0 to (1- row) do
		(loop for j from 0 to (1- colomn) do
			(cond ((= 1 (element lst i j)) (return-from get-first-element-in-list (list i j edge-type)))))))

;;returns the first edge to start the check whether the puzzle got completed or not
(defun get-first-edge(horizontal-edges vertical-edges)
	(setq temph (get-first-element-in-list horizontal-edges (1+ rows) colomns 'h))
	(cond ((equal nil temph) 
				 	(setq tempv (get-first-element-in-list vertical-edges rows (1+ colomns) 'v))
				 	(cond ((equal nil tempv)  tempv)
				 				( t tempv)))
				( t temph)
))

(defun are-edges-equal(edge1 edge2)
	(cond (
					(equal (length edge1) (length edge2)) 
					(cond ((equal nil edge1) 
										(cond ((equal nil edge2) T)
											(T nil))
								)
								( T (and (equal (car edge1) (car edge2)) (are-edges-equal (cdr edge1) (cdr edge2))))
					)
				)
				( T nil)
	)) 
;; function to count the number of edges in the whole puzzle.
(defun count-edges(edge-list)
	(cond ((atom (car edge-list)) 
						(cond ((equal 1 (car edge-list)) (1+ (count-edges (cdr edge-list))))
									((equal nil (car edge-list)) 0)
									(t (count-edges (cdr edge-list)))))

				((listp (car edge-list)) (+ (count-edges (car edge-list)) (count-edges (cdr edge-list))))
	))

(defun print-horizontal-edge(edge)
	(loop for i in edge
		do (cond 	((= 1 i) (format t "+-"))
						( t (format t "+ "))))
	(format t "+")
)

(defun print-horizontal-edge-file(edge out)
	(if (equal nil out) (return-from print-horizontal-edge-file NIL))
	(loop for i in edge
		do (cond 	((= 1 i) (format out "+-"))
						( t (format out "+ "))))
	(format out "+")
)

;(defun foo(x out) (format t "~d" x))

(defun print-board-row(boardrow verticalrow colomns)
	(loop for i from 0 to (1- colomns)
				do(cond ((= 1 (nth i verticalrow)) (format t "|"))
								( t (format t " ")))
				do(cond ((= 5 (nth i boardrow)) (format t " "))
								( t (format t "~d" (nth i boardrow)))))
	(cond ((= 1 (nth colomns verticalrow)) (format t "|"))
								( t (format t " "))))

(defun print-board-row-file(boardrow verticalrow colomns out)
	(if (equal nil out) (return-from print-board-row-file NIL))
	(loop for i from 0 to (1- colomns)
				do(cond ((= 1 (nth i verticalrow)) (format out "|"))
								( t (format out " ")))
				do(cond ((= 5 (nth i boardrow)) (format out " "))
								( t (format out "~d" (nth i boardrow)))))
	(cond ((= 1 (nth colomns verticalrow)) (format out "|"))
								( t (format out " "))))

(defun make-board-row(board-row vertical-edge-row)
	(loop for i in board-row
				for j in vertical-edge-row
				collect (list i j)))

(defun update-horizontal-edge(x y z val)
	(set-element horizontal-edges (+ x z) y val))
(defun update-vertical-edge(x y z val)
	(set-element vertical-edges x (+ y z) val))

(defun update-edge(x y which-edge val)
	(cond ((equal 'T which-edge) (update-horizontal-edge x y 0 val)) ;; top-edge
				((equal 'B which-edge) (update-horizontal-edge x y 1 val)) ;; bottom-edge
				((equal 'L which-edge) (update-vertical-edge x y 0 val)) ;; left-edge
				((equal 'R which-edge) (update-vertical-edge x y 1 val)))) ;; right-edge

(defun get-coordinates(val) 
	(princ "Enter the edge for the element")
	(terpri)
	(setq x (read ))
	(setq y (read ))
	(setq z (read ))
	(if (or (> x rows) (> y colomns) (not (or (equal 'T z) (equal 'R z) (equal 'L z) (equal 'B z))))
		(progn 
			(princ "Invalid edge. Please try again: ")
			(terpri)
			(get-coordinates val)
		)
		(update-edge (1- x) (1- y) z val)
	)
)

(defun find-loop(prev-edge current-edge)
	(if (equal nil prev-edge) (return-from find-loop NIL))
	(if (equal nil current-edge) (return-from find-loop NIL))
	(let 	((next-edge nil)
				 (neighbor-list ())	
				)
			(setq neighbor-list (get-existing-neighbor-edges current-edge))
			(if (not (equal 2 (length neighbor-list))) (return-from find-loop NIL))
			(setf next-edge (get-next-edge-in-loop neighbor-list prev-edge))
			(if (equal next-edge nil) (return-from find-loop NIL))
			(setq edge-count-in-loop (1+ edge-count-in-loop))
			(if (equal next-edge first-edge) 
				(if(< edge-count-in-loop 4) (return-from find-loop NIL) T)
				(find-loop current-edge next-edge))
	)
)

(defun check-loop()
	(setf first-edge (get-first-edge horizontal-edges vertical-edges))
	(if (equal first-edge nil) (return-from check-loop NIL))
	(setf edge-count-in-loop 1)
	(find-loop first-edge (nth 0 (get-existing-neighbor-edges first-edge)))
)

(defun check-if-completed()
		(if (validate-each-board-entry)
			(if (check-loop) 
					( if (equal (+ (count-edges horizontal-edges)(count-edges vertical-edges)) edge-count-in-loop)
								T 
								NIL
					)
					NIL
			)
			NIL
		)
)

(defun get-edges-in-final-loop()
	(let ((next-edge NIL))
		(setf first-edge (get-first-edge horizontal-edges vertical-edges))
		(setf next-edge (car (get-existing-neighbor-edges first-edge)))
		(setf final-list (list first-edge next-edge))
		(get-final-list first-edge next-edge)
	)
)

(defun get-final-list(prev-edge edge)
	(let ((next-edge (get-next-edge-in-loop (get-existing-neighbor-edges edge) prev-edge)) 
			)
	(if (equal first-edge next-edge)
		(return-from get-final-list final-list)
		(progn
			(setq final-list (append final-list (list next-edge)))
			(get-final-list edge next-edge)
		)
	)
	)
)

(defun print-final-list()
	(print-edges (get-edges-in-final-loop))
)

(defun partial-validate-each-board-entry()
	(loop for i from 0 to (1- rows) do
		(loop for j from 0 to (1- colomns) do
			(validate-entry (list i j))
		)
	)
)

(defun validate-entry(entry)
	(let ((i (nth 0 entry))
				(j (nth 1 entry)))
		(if (and (>= i 0) (>= j 0) (< i rows)(< j colomns))
			(progn 	
				(setf temp (element board i j))
				;(terpri)
				;(princ "val entry: ")
				;(princ temp)
				;(terpri)
				;(princ "no of edges")
				;(princ (length (get-existing-edges (get-all-edges-for-board-entry entry))))
				(if (not (equal 5 temp))
					(if (< temp (length (get-existing-edges (get-all-edges-for-board-entry entry))))
						(progn
							(return-from validate-entry NIL)
						)
						T
					)
					T
				)
			)
			T
		)
	)
)

(defun partial-validate-adjacent-entries(edge)
	(loop for entry in (get-adjacent-board-entries-for-edge edge) do
		;(terpri)
		;(princ "Entry is: ")
		;(princ entry)
		(if (equal (validate-entry entry) NIL)
			(return-from partial-validate-adjacent-entries NIL)
		)
	)
	T	
)

(defun validate-each-board-entry()
	(loop for i from 0 to (1- rows) do
		(loop for j from 0 to (1- colomns) do
				(setf temp (element board i j))
				(if (not (equal 5 temp))
					(if (not (equal temp (length (get-existing-edges (get-all-edges-for-board-entry (list i j))))))
						(return-from validate-each-board-entry NIL)
					)
				)
		)
	)
	T
)

;(defun get-first-three-on-board()
;	(loop for i from 0 to (1- rows) do
;		(loop for j from 0 to ( 1- colomns) do
;			(if (and (not (equal 5 (element board i j))) ())
;		)
;	)
;)
(defun get-first-entry-on-board(lst row colomn)
	(loop for i from 0 to (1- row) do
		(loop for j from 0 to (1- colomn) do
			(if (and (not (equal 5 (element lst i j ))) (equal 3 (element lst i j)))
				(return-from get-first-entry-on-board (list i j))
			)
		)
	)
)

(defun get-all-edges-for-board-entry(lst)
	(let ((i (car lst))
				(j (cadr lst)))	
				(list (list i j symbol-horizontal) (list (1+ i) j symbol-horizontal)
							(list i j symbol-vertical) (list i (1+ j) symbol-vertical))
))

(defun print-board(board horizontal-edges vertical-edges rows colomns)
	(print-horizontal-edge (nth 0 horizontal-edges))
	(terpri)
	(loop for i from 1 to rows
	do (print-board-row (nth (1- i) board) (nth (1- i) vertical-edges) colomns)
	do (terpri)
	do (print-horizontal-edge (nth i horizontal-edges))
	do (terpri)
	))

(defun pboard-file(out)
	(print-horizontal-edge-file (nth 0 horizontal-edges) out)
	(format out "~%")
	(loop for i from 1 to rows
	do (print-board-row-file (nth (1- i) board) (nth (1- i) vertical-edges) colomns out)
	do (format out "~%")
	do (print-horizontal-edge-file (nth i horizontal-edges) out)
	do (format out "~%")
	))

(defun print-edges(lst)
	(terpri)
	(if (not (equal NIL (car lst)))
		(progn (princ (convert-edge (car lst))) (print-edges (cdr lst)))
	)
)

(defun make-edge()
	(get-coordinates 1)
	(print-board board horizontal-edges vertical-edges rows colomns)
	(if (check-if-completed) (game-finished) (get-input))
)

(defun delete-edge()
	(get-coordinates 0)
	(print-board board horizontal-edges vertical-edges rows colomns)
	(if (check-if-completed) (quit-current-game) (get-input))
)

;;changes the edge not through board
(defun change-edge(edge val)
	(if (equal symbol-horizontal (nth 2 edge))
			(set-element horizontal-edges (nth 0 edge)(nth 1 edge) val) 
			(set-element vertical-edges (nth 0 edge)(nth 1 edge) val)
	)	
)

(defun quit-current-game()
	(terpri)
	(princ "Ending current game")
	(terpri)
	(print-board board horizontal-edges vertical-edges rows colomns)
	
)
(defun game-finished()
	(princ "You successfully finished the current game")
	(terpri)
	(print-board board horizontal-edges vertical-edges rows colomns)
	(terpri)
	(princ "Edges for the solution: ")
	(terpri)
	(print-final-list)
	(terpri)
	(princ "Enter 1 to start a new game or any other key to exit")
	(terpri)
	(cond ((equal 1 (read) ) (start-game)))
)

(defun get-input()
	(princ "Press 1 to make an edge")
	(terpri)
	(princ "Press 2 to delete an edge")
	(terpri)
	(princ "Press 3 to quit the game")
	(terpri)
	(setq input (read))
	(cond ((= 1 input) (make-edge)) 
				((= 2 input) (delete-edge))
				((= 3 input) (quit-current-game))
				( t (princ "Enter correct values")(terpri)(print-board board horizontal-edges vertical-edges rows colomns)(get-input))
	))
	
(defun display-rules()
	(princ "Each puzzle consists of a rectangular lattice of dots with some clues in various places. The object is to link adjacent dots so:")
	(terpri)
	(princ "1. The value of each clue equals the number of links surrounding it.") 
	(terpri)
	(princ "2. Empty squares may be surrounded by any number of links.")
	(terpri)
	(princ "3. When completed, the solution forms a single continuous loop with no crossings or branches.")
	(terpri)
	(princ "Press 1 to start the game or any other key to quit")
	(terpri)
	(cond ((equal 1 (read) ) (start-game)))
)
(defun start-game()
	(princ "Enter filename: ")
	(terpri)
	(setq filename (read-line))
	(read-file filename)
	(print-board board horizontal-edges vertical-edges rows colomns)
	(terpri)
	(terpri)
	(princ "Press 1 to play manually.")
	(terpri)
	(princ "Press 2 to use AI. ")
	(terpri)
	(princ "Press any other key to exit.")
	(terpri)
	(let ((inp (read )))
		(if (equal 1 inp) 
			(get-input)
			(progn
				(if (equal 2 inp)
					(progn
						(time (solve-slither))
						(terpri)
						(princ "Find the output at: ")
						(princ output-filename)
						(terpri)
						(princ "Enter 1 to start a new game or any other key to exit")
						(terpri)
						(cond ((equal 1 (read) ) (start-game)))
					)
					(progn
						(terpri)
						(princ "Exiting ")
						(terpri)
					)
				)
			)
		)
	)
)

(defun slither()
	(display-rules)
		
)

;(defun get-first-unvisited-edge(edges)
;	(cond ((equal edges nil) nil)
;		((equal (car edges) nil) nil)
;		((equal (gethash (car edges) visited-edges) nil)(car edges))
;		(t (get-first-unvisited-edge (cdr edges)))
;	)
;)

;(defun get-non-discarded-edges(edge-list)
;	(setf existing-edges nil)
;	(loop for edge in edge-list do
;		(if (equal NIL (gethash edge discarded-edges))
;			(if (equal existing-edges NIL)
;				(setf existing-edges (list edge))
;				(setf existing-edges (append (list edge) existing-edges))
;			)
;		)
;	)
;	existing-edges
;)

(defun get-adjacent-board-entries-for-edge(edge)
	(if (equal edge NIL) NIL)
	(if (equal symbol-horizontal (nth 2 edge))
		(get-adjacent-board-entries-for-horizontal-edge edge)
		(get-adjacent-board-entries-for-vertical-edge edge)
	)
)

(defun get-adjacent-board-entries-for-horizontal-edge(edge)
	(if (equal edge NIL) NIL)
	(let ((i (nth 0 edge))
				(j (nth 1 edge)))		
		(list (list i j) (list (1- i) j))
	)
)

(defun get-adjacent-board-entries-for-vertical-edge(edge)
	(if (equal edge NIL) NIL)
	(let ((i (nth 0 edge))
				(j (nth 1 edge)))
			(list (list i j) (list i (1- j)))
	)
)

(defun calculate-priority(lst)
	(let ((i 0)
				(j 0)
				(val1 0))
		(setf priority 0)
		(loop for entry in lst do
			(setf i (nth 0 entry))
			(setf j (nth 1 entry))
			(if (and (>= i 0) (< i rows) (>= j 0) (< j colomns))
				(progn 
					(setf val1 (element board i j))
					(if (equal val1 0) (return-from calculate-priority -1))
					(if (not (equal val1 5)) (setf priority (+ priority val1)))
				)
			)
		)	
	)
	priority
)

(defun find-priority(edge)
	(calculate-priority (get-adjacent-board-entries-for-edge edge))
)

(defun set-priority(edge val)
	(if (equal edge NIL) (return-from set-priority NIL))
	(if (equal (nth 2 edge) symbol-horizontal) 
		(set-element horizontal-edges-priority-values (nth 0 edge) (nth 1 edge) val)
		(set-element vertical-edges-priority-values (nth 0 edge) (nth 1 edge) val)
	)
)

;(defun check-first-corner()
;	(let ((val (element board 0 0)))
;		(if (equal val 0) 
;			(progn
;				(set-priority '(0 1 H) -1)
;				(set-priority '(1 0 V) -1)
;			)
;		)
;		(if (equal val 1)
;			(progn
;
;			)
;		)
;	)
;)

;(defun get-corner-edges(corner)
;	(if (equal (nth 0 corner) 0)
;		(if (equal (nth 1 corner) 0)
;			(return-from get-corner-edges '((0 1 symbol-horizontal) (1 0 symbol-vertical)))
;		)
;		(if (equal (nth 1 corner) (1- colomns)) 
;			(return-from get-corner-edges '(()()))
;		)
;	)
;
;)

(defun get-priority(edge)
	(if (equal edge NIL) (return-from get-priority NIL))
	(if (equal symbol-horizontal (nth 2 edge)) 
		(element horizontal-edges-priority-values (nth 0 edge) (nth 1 edge))
		(element vertical-edges-priority-values (nth 0 edge) (nth 1 edge))
	)
)

(defun pboard()
	(print-board board horizontal-edges vertical-edges rows colomns)
)

(defun get-pre-existing-neighbor-edges(edge)
	(get-pre-existing-edges (get-neighbors edge))
)

(defun get-pre-existing-edges(edges)
	(setf pre-existing-neighbors nil)
	(loop 
		for edge in edges do
		(if (equal T (is-pre-existing-edge edge))
			(if (equal nil pre-existing-neighbors)
				(setf pre-existing-neighbors (list edge))
				(setf pre-existing-neighbors (append pre-existing-neighbors (list edge)))
			)
		)
	)
	pre-existing-neighbors
)

(defun get-neighbor-on-first-side(edge)
	(if (equal (nth 2 edge) symbol-horizontal)
		(get-neighbor-on-first-side-horizontal-edge edge)
		(get-neighbor-on-first-side-vertical-edge edge)
	)
)

(defun get-neighbor-on-second-side (edge)
	(if (equal (nth 2 edge) symbol-horizontal)
		(get-neighbor-on-second-side-horizontal-edge edge)
		(get-neighbor-on-second-side-vertical-edge edge)
	)
)

(defun get-neighbor-on-first-side-horizontal-edge(edge)
	(let ((i (nth 0 edge))
				(j (nth 1 edge)))
	(list (list i (1- j) symbol-horizontal)
				(list (1- i) j symbol-vertical)
				(list i j symbol-vertical)
	)
	)
)

(defun get-neighbor-on-second-side-horizontal-edge(edge)
	(let ((i (nth 0 edge))
				(j (nth 1 edge)))
	(list (list i (1+ j) symbol-horizontal) 
				(list (1- i) (1+ j) symbol-vertical)
				(list i (1+ j) symbol-vertical)
	)
	)
)

(defun get-neighbor-on-first-side-vertical-edge(edge)
	(let ((i (nth 0 edge))
				(j (nth 1 edge)))
	(list (list (1- i) j symbol-vertical) 
				(list i j symbol-horizontal)
				(list i (1- j) symbol-horizontal)
	)
	)
)

(defun get-neighbor-on-second-side-vertical-edge(edge)
	(let ((i (nth 0 edge))
				(j (nth 1 edge)))
	(list (list (1+ i) j symbol-vertical)
				(list (1+ i) (1- j) symbol-horizontal) 
				(list (1+ i) j symbol-horizontal)
	) 
	)
)

(defun check-if-existing-neighbors-on-same-side(edge)
	(if (equal 2 (length (get-existing-edges (get-neighbor-on-first-side edge))))
		(progn 
			(return-from check-if-existing-neighbors-on-same-side T)
		)
		(progn
			(if(equal 2 (length (get-existing-edges (get-neighbor-on-second-side edge))))
				(return-from check-if-existing-neighbors-on-same-side T)
			)
		)
	)
)

(defun remove-edge-from-board(edge)
	(if (not (is-pre-existing-edge edge))
		(progn
		;(terpri)
		;(princ "removing edge")
		(change-edge edge 0)
		;(terpri)
		;(pboard)
	))
	(if (not (equal NIL out))
		(progn
			(format out "~%")
			(format out "Cannot make edge: ")
			(plist-file (convert-edge edge) out)
			(format out "~%")
			(pboard-file out)
		)
	)
)

(defun plist-file(list out)
	(if (equal NIL out) (return-from plist-file NIL))
	(loop for cons on list
    do (format out "~a" (car cons))
    when (cdr cons) do (format out " "))
)

;consider only non-existing non-visited neighbors in the edge-list
(defun solution(prev-edge edge)
	(if (> moves limit-moves) (return-from solution NIL))
;	(terpri)
;	(princ "in solution:")
;(terpri)
;(princ "Edge is: ")
;(princ edge)
;	(terpri)
;	(princ "prev-edge is ")
;	(princ prev-edge)

	(if (equal NIL edge) 
		(progn 
			(return-from solution NIL)
		)
	)
	(setf moves (1+ moves))
	(if (not(is-pre-existing-edge edge))
		(progn
			(if (equal -1 (get-priority edge))
				(progn
					;(terpri)
					;(princ "Touched an edge around 0")
					(return-from solution NIL)
				)
			)
			;(terpri)
			;(princ "Making edge: ")
			(change-edge edge 1)
		)
	)

	(if (not (equal NIL out))
		(progn
			(format out "~%")
			(format out "Making Edge: ")
			(plist-file (convert-edge edge) out)
			(format out "~%")
			(pboard-file out)
			(format out "~%")
		)
	)
	
;	(terpri)
;	(pboard)
	(if (not (partial-validate-adjacent-entries edge))
		(progn 
;			(terpri)
;			(princ "All partial entries not valid")
			(remove-edge-from-board edge)
			(return-from solution NIL)
		)
	)

	(let ((pre-existing-neig-li (get-pre-existing-neighbor-edges edge))
				(number-of-existing-neighbors (length (get-existing-neighbor-edges edge)))
		)
		(if (>= number-of-existing-neighbors 3) 
			(progn 
				(remove-edge-from-board edge)
				(return-from solution NIL)
			)
		)
		(if(equal number-of-existing-neighbors 2)
			(progn 
;				(terpri)
;				(princ "check if two neighbor on same side: ")
;				(princ (check-if-existing-neighbors-on-same-side edge))
;				(princ "here::")
				(if (check-if-existing-neighbors-on-same-side edge)
					(progn 
	;					(terpri)
	;					(princ "in:")
						(remove-edge-from-board edge)
						(return-from solution NIL)
					)
				)
	;			(terpri)
	;			(princ "Checking if its the last edge")
				;; Need to check if the edge
				(if (equal T (check-loop))
					(progn
						;(terpri)
	;					(princ "Yes. Found a loop")
						(if (check-if-completed) 
							(progn 
								(terpri)
								(princ "FOUND THE SOLUTION")
								(terpri)
								(pboard)
								;(terpri)
								;(princ edge)
								;(terpri)
								;(princ "Edges for the solution: ")
								(return-from solution (list edge))
							)
							(progn 
	;							(terpri)
	;							(princ "All entries not valid")
								(remove-edge-from-board edge)
								(return-from solution NIL)
							)
						)
					)
					(progn 
	;					(terpri)
	;					(princ "No loop found")
						(if (equal NIL pre-existing-neig-li)
							(progn
	;							(terpri)
	;							(princ "No loop. Deleting the edge")
	;							(terpri)
	;							(princ "pre-existing edges for : ")
	;							(princ edge)
	;							(princ " are ")
	;							(princ pre-existing-neig-li)
								(remove-edge-from-board edge)
								(return-from solution NIL)					
							)
							(progn
	;							(terpri)
	;							(princ "Going further:::")
								(if (equal 1 (length pre-existing-neig-li))
									(progn 
	;									(terpri)
	;									(princ "one pre-existing neighbor")
										(if (equal prev-edge (car pre-existing-neig-li))
											(solution-helper prev-edge edge NIL)
											(solution-helper edge (car pre-existing-neig-li) T)
										)
									)
									(progn
										(if (equal 2 (length pre-existing-neig-li))
											(progn
											;(terpri)
												;(princ "two pre-existing neighbor")
											;	(terpri)
											;	(princ "list is: ")
											;	(princ pre-existing-neig-li)
											;	(terpri)
											;	(princ "prev is: ")
											;	(princ prev-edge)
											;	(princ " : get next: ")
											;	(print (get-next-edge-in-loop pre-existing-neig-li prev-edge))
												(if (equal NIL prev-edge)
													(solution-helper edge (car (get-existing-neighbor-edges edge)) NIL)	
													(solution-helper edge (get-next-edge-in-loop pre-existing-neig-li prev-edge) T))
											)
											NIL
										)
									)
								)
							)
						)
					)
				)
			)
			(progn 
	;			(terpri)
	;			(princ "Checking further::: ")
				(if (equal NIL pre-existing-neig-li)
					(progn 
	;					(terpri)
	;					(princ "No pre-existing")
						(solution-helper prev-edge edge NIL)
					)
					(progn
						(if (equal 1 (length pre-existing-neig-li))
							(progn 
	;							(terpri)
	;							(princ "one pre-existing")
								(if (equal prev-edge (car pre-existing-neig-li))
									(solution-helper prev-edge edge NIL)
									(solution-helper edge (car pre-existing-neig-li) T)
								)
							)
							(progn
								(if (equal 2 (length pre-existing-neig-li))
									(progn
									;	(terpri)
									;	(princ "two pre-existing")	
										(solution-helper edge (get-next-edge-in-loop pre-existing-neig-li prev-edge) T)
									)
									NIL
								)
							)
						)
					)
				)
			)
		)
	)
)

(defun is-edge-in-list(edge edge-list)
	(loop for e in edge-list do
		(if (equal e edge)
			(return-from is-edge-in-list T)
		)
	)
)

(defun solution-helper(prev-edge edge is-pre-existing)
;	(terpri)
;	(princ "in solution-helper for edge: ")
;	(princ edge)

	(let ((tmp NIL))
		(if (not is-pre-existing)
		(setf tmp (solution-make-neighbor-edges prev-edge edge (get-non-existing-neighbor-edges prev-edge edge)))
		(setf tmp (solution prev-edge edge)))
		(if (not (equal NIL tmp))
			(progn
				;(terpri)
				;(princ edge)
				(return-From solution-helper (append (list edge) tmp))
			)
			(progn
				(if (not is-pre-existing)
					(progn 
;						(terpri)
;						(princ "Cannot form solution with any of the neighbor edges. Deleting the edge: ")
;						(princ edge)
						(remove-edge-from-board edge)
					)
					(progn 
;						(terpri)
;						(princ "Cannot form solution with any of the neighbor edges. Deleting the edge: ")
;						(princ prev-edge)
						(remove-edge-from-board prev-edge)
					)
				)
				(return-from solution-helper NIL)
			)
		)
	)
)
;(defun solution-make-neighbor-edges(edge-list)
;	(if (equal nil edge-list)
;		(progn
;			(terpri)
;			(princ "neighbor-list is nil")
;			(return-from solution-make-neighbor-edges NIL)
;		)
;	)
;	(let ((tmp1 NIL))
;		(loop for edge in edge-list do
;			(setf tmp1 (solution edge))
;			(if (not (equal NIL tmp1))
;				(progn
;					;(terpri)
;					;(princ "Yayy. Found loop")
;					(return-from solution-make-neighbor-edges tmp1)
;				)
;				;(progn
;					;(terpri)
;					;(princ "No solution with this edge. Lets try next one.")
;				;)
;			)
;		)
;	)
;	NIL
;)

(defun solution-make-neighbor-edges(prev-edge this-edge edge-list)
	;(terpri)
	;(princ "in making neighbor for edge: ")
	;(princ this-edge)
	;(terpri)
	;(princ "Making neighbor for edge: ")
	;(princ this-edge)
	(if (equal NIL edge-list) (return-from solution-make-neighbor-edges NIL))
	(loop for edge in edge-list do
		(if (and (is-pre-existing-edge edge) (not(are-edges-equal prev-edge edge)))
			(progn 
		;	(terpri)
		;	(princ "found pre-existing edge: ")
		;	(princ edge)
				(return-from solution-make-neighbor-edges (solution this-edge edge))
			)
		)
	)
	(let ((tmp1 NIL)
				(len (length edge-list)))
		(loop for i from 0 to (1- len) do
			(setf edge-list (get-max-priority-edge-list edge-list))
		;	(terpri)
		;	(princ "Neighbor edge is: ")
		;	(princ (car edge-list))
			(setf tmp1 (solution this-edge (car edge-list)))
			(if (not (equal NIL tmp1))
				(progn
		;			(terpri)
		;			(princ "Yayy. Found loop")
					(return-from solution-make-neighbor-edges tmp1)
				)
				(progn
		;			(terpri)
		;			(princ "No solution with this edge: ")
		;			(princ (car edge-list))
		;			(princ " Lets try next neighbor for: ")
		;			(princ this-edge)
					(setf edge-list (cdr edge-list))
					;(return-from solution-make-neighbor-edges NIL)
				)
			)
		)
	)
;	(terpri)
;	(princ "Tried all the neighbors. No solution for edge: ")
;	(princ this-edge)
	NIL
)

(defun get-max-priority-edge-list(lst)
	(let ((temp NIL)) 
		(if (equal lst NIL) (return-from get-max-priority-edge-list NIL))
		(if (equal 1 (length lst)) (progn (return-from get-max-priority-edge-list lst)))
		(setf temp (get-max-priority-edge-list (cdr lst)))
		(if (< (get-priority (car lst)) (get-priority (car temp)))
			(append (list (car temp) (car lst)) (cdr temp))
			lst
		)
	)
)

(defun add-to-hash(map element val)
	(setf (gethash element map) val)
)

(defun print-hash-entry (key value)
    (format t "The value associated with the key ~S is ~S~%" key value))

(defun print-hash-table(hash-table)
	(maphash #'print-hash-entry hash-table)
)

(defun clear-hash-table(table)
	(loop for key being the hash-keys of table do
		(remhash key table)
	)
)

(defun is-pre-existing-edge(edge)
	(gethash edge pre-existing-edges)
)

(defun calculate-priority-for-each-branch()
	;;for horizontal-branches
	(let ((tempval 0))
		(loop for i from 0 to rows do
			(loop for j from 0 to (1- colomns) do
				(setf tempval (find-priority (list i j symbol-horizontal)))
				(set-element horizontal-edges-priority-values i j tempval)
				(if (equal tempval 6)
					(progn
						(change-edge (list i j symbol-horizontal) 1)
						(change-edge (list (1- i) j symbol-horizontal) 1)
						(change-edge (list (1+ i) j symbol-horizontal) 1)
						(add-to-hash pre-existing-edges (list i j symbol-horizontal) T)
						(add-to-hash pre-existing-edges (list (1- i) j symbol-horizontal) T)
						(add-to-hash pre-existing-edges (list (1+ i) j symbol-horizontal) T)
					)
				)
			)
		)
		;;for vertical-branches
		(loop for i from 0 to (1- rows) do
			(loop for j from 0 to colomns do
				(setf tempval (find-priority (list i j symbol-vertical)))
				(set-element vertical-edges-priority-values i j tempval)
				(if (equal tempval 6)
					(progn
						(change-edge (list i j symbol-vertical) 1)
						(change-edge (list i (1+ j) symbol-vertical) 1)
						(change-edge (list i (1- j) symbol-vertical) 1)
						(add-to-hash pre-existing-edges (list i j symbol-vertical) T)
						(add-to-hash pre-existing-edges (list i (1- j) symbol-vertical) T)
						(add-to-hash pre-existing-edges (list i (1+ j) symbol-vertical) T)
					)
				)
			)
		)
	)
)

(defun check-for-three-and-zeros-together()
	(loop for i from 0 to (1- rows) do
		(loop for j from 0 to (1- colomns) do
			(if (equal (element board i j) 3)
				(progn
					(loop for edge in (get-all-edges-for-board-entry (list i j)) do
						(if (equal -1 (get-priority edge))
							(progn
								;(terpri)
								;(princ "found it at: ")
								;(princ (list i j))
								;(terpri)
								;(princ "Edge is: ")
								;(princ edge)
								(make-edges-around-zero-and-three edge (get-all-edges-for-board-entry (list i j)))
							)
						)
					)
				)
			)
		)
	)
)

(defun make-edges-around-zero-and-three(edge edge-list)
	(loop for e in edge-list do
		(if (not (are-edges-equal edge e))
			(progn 
				;(terpri)
				;(princ "Actual Edge: ")
				;(princ edge)
				;(terpri)
				;(princ "neighbor edge is: ")
				;(princ e)
				(change-edge e 1)
				(add-to-hash pre-existing-edges e T)
			)
		)
	)
	(make-adjacent-edges-around-zero edge)
)

(defun make-adjacent-edges-around-zero(edge)
	(if (equal NIL edge)(return-from make-adjacent-edges-around-zero NIL))
	(if (equal symbol-horizontal (nth 2 edge))
		(progn
			;(terpri)
			;(pboard)
			;(terpri)
			;(princ "Changing edges")
			;(terpri)
			(change-edge (list (nth 0 edge) (1- (nth 1 edge)) symbol-horizontal) 1)
			(add-to-hash pre-existing-edges (list (nth 0 edge) (1- (nth 1 edge)) symbol-horizontal) T)
			;(pboard)
			;(terpri)
			;(princ "Changing edges")
			(change-edge (list (nth 0 edge) (1+ (nth 1 edge)) symbol-horizontal) 1)
			(add-to-hash pre-existing-edges (list (nth 0 edge) (1+ (nth 1 edge)) symbol-horizontal) T)
			;(terpri)
			;(pboard)
		)
		(progn
			;(terpri)
			;(pboard)
			;(terpri)
			;(princ "Changing edges-vertical")
			;(terpri)
			(change-edge (list (1- (nth 0 edge)) (nth 1 edge) symbol-vertical) 1)
			(add-to-hash pre-existing-edges (list (1- (nth 0 edge)) (nth 1 edge) symbol-vertical) T)
			;(pboard)
			;(terpri)
			;(princ "Changing edges-vertical")
			(change-edge (list (1+ (nth 0 edge)) (nth 1 edge) symbol-vertical) 1)
			(add-to-hash pre-existing-edges (list (1+ (nth 0 edge)) (nth 1 edge) symbol-vertical) T)
			;(terpri)
			;(pboard)
		)
	)
)

(defun get-output-stream (out_file)
  (open out_file :if-does-not-exist :create
  							:if-exists :overwrite
  							:direction :output)
 )

(defun solve-slither()
	(setf output-filename (concatenate 'string  "solution-" fileName))
	(setf out (get-output-stream output-filename))
	(format out "writing")
	(format out "~%")
	(pboard-file out)
	
	(calculate-priority-for-each-branch)
	(check-for-three-and-zeros-together)
	(terpri)
	(princ "pre-existing edges in board: ")
	(terpri)
	(pboard)
	(let ((point (get-first-entry-on-board board rows colomns))
				(initial-edge-list '(-1 -1 H)))
		;(terpri)
		;(princ "point: ")
		;(princ point)
		(if (equal nil point) 
				(progn (princ "Incorrect values on board. Cannot be solved") 
					(terpri)
					(return-from solve-slither NIL)))
		(setf initial-edge-list (get-all-edges-for-board-entry point))
		(if (not (equal NIL (solution-make-neighbor-edges NIL NIL initial-edge-list)))
			(progn
				(terpri)
				(princ "Total moves to get to solution:  ")
				(princ moves)
				(terpri)
				(princ "Edges for the solution: ")
				(print-final-list)
			)
			(progn 
				(if (> moves limit-moves)
					(progn
						(terpri)
						(princ "No solution found in given number of moves: ")
						(princ limit-moves)
						(terpri)
						(princ "Total moves tried to get to solution: ")
						(princ moves)
						(terpri)
						(princ "Final board: ")
						(terpri)
						(pboard)
					)
					(progn
						(terpri)
						(princ "No solution found")
						(terpri)
					)
				)
			)
		)
		(clear-hash-table pre-existing-edges)
		(setf moves 0)
		(close out)
	)	
)
